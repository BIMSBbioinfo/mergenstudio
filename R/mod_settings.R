#' @importFrom bslib accordion accordion_panel tooltip
#' @importFrom fontawesome fa
#' @importFrom shinyjs useShinyjs hidden disabled
#' @importFrom shinyFiles shinyDirButton
#' @noRd
mod_settings_ui <- function(id, translator = create_translator(), dir = NULL) {
  ns <- NS(id)

  # api_services <- c("openai-chat", "openai-completion", "replicate")
  api_services <- c("openai", "replicate", "generic")

  preferences <- bslib::accordion(
    open = FALSE,
    multiple = FALSE,

    bslib::accordion(open = TRUE,
      bslib::accordion_panel(
        title = "Chat Options",
        icon = fontawesome::fa("sliders"),

        selectizeInput(
          inputId = ns("custom_context"),
          label = getIconLabel(translator$t("Select Context"),
                               message="Optional context to provide alongside with the prompt to help LLM model to help user in different ways. If 'No Context' is selected, no context will be provided. You can also enter a custom context by typing on this box"
          ),
          choices = get_available_context(),
          width = "200px",
          selected = NULL,
          options = list(create = TRUE)
        ),

        # directoryInput(inputId = ns('directory'),
        #                label = getIconLabel("Select Directory",
        #                                     message="Selecting the working directory for code execution. Once the execute code button is clicked, this directory will be used for reading and saving files."
        #                ),
        #                value = getwd()),
        # shinyjs::disabled(
          textInput(inputId = ns("directorytext"),
                    label = getIconLabel("Select Directory",
                                         message="Selecting the working directory for code execution. Once the execute code button is clicked, this directory will be used for reading and saving files."
                    ),
                    value = ifelse(is.null(dir), getwd(), dir)
          ),
        # ),
        column(4,
               shinyFiles::shinyDirButton(id = ns('directory'),
                                          label = "...", title = "Select Directory",
                                          class = "btn action-button btn-primary",
                                          style = "padding:2px; font-size:90%; width: 100%; margin-bottom: 20px; margin-top: -14px; margin-left: 0px", buttonType = "default")
                                          # style = "width: 60%; height: 50%; margin-bottom: 20px; margin-top: -14px; margin-left: 0px", buttonType = "blue")
        ),
        radioButtons(
          inputId = ns("autoexecution"),
          label = getIconLabel("Activate Auto execution",
                               message = "Activating auto execution will automatically try to run any code that is generated by the agent"
          ),
          choiceNames = c("Yes", "No"),
          choiceValues = c(TRUE, FALSE),
          selected = FALSE,
          inline = TRUE,
          width = "200px",
        ),
        radioButtons(
          inputId = ns("selfcorrect"),
          label = getIconLabel("Activate Self Correct",
                               message = "Activating Self Correct will attempt to correct code that is returned by the agent if it results in errors, by resending the prompt together with additional information about the error message."
          ),
          choiceNames = c("Yes", "No"),
          choiceValues = c(TRUE, FALSE),
          selected = FALSE,
          inline = TRUE,
          width = "200px",
        ),
        radioButtons(
          inputId = ns("fileheader"),
          label = getIconLabel("Activate file header addition",
                               message="Activating file header addition will attempt to add the first few lines of files mentioned in your prompt to your prompt. The directory that will be searched can be set in 'select directory'"
          ),
          choiceNames = c("Yes","No"),
          choiceValues = c(TRUE, FALSE),
          selected = FALSE,
          inline = TRUE,
          width = "200px",
        )
      )
    ),

    bslib::accordion(open = FALSE,
      bslib::accordion_panel(
        title = "API Options",
        icon = fontawesome::fa("server"),

        selectInput(
          inputId = ns("service"),
          label = translator$t("Select API Service"),
          choices = api_services,
          selected = getOption("mergenstudio.service"),
          width = "200px"
        ),
        textInput(
          inputId = ns("api_key"),
          label = translator$t("API Key"),
          value = "",
          width = "200px"
        ),
        textInput(
          inputId = ns("api_url"),
          label = getIconLabel(translator$t("API URL (only needed for 'generic')"),
                               message="Provide an API URL. This is only needed when service is set to generic."
                               ),
          value = "",
          width = "200px"
        ),
        selectizeInput(
          inputId = ns("model"),
          label = translator$t("Chat Model"),
          choices = get_available_models(getOption("mergenstudio.service"))[1],
          width = "200px",
          selected = getOption("mergenstudio.model"),
          options = list(create = TRUE)
        ),
        selectizeInput(
          inputId = ns("nr_tokens"),
          label = getIconLabel(translator$t("Nr of tokens"),
                               message="Maximum amount of tokens to send to LLM."),
          choices = seq(3000,10000,by=1000),
          selected = 4000
        )
      )
    ),

    bslib::accordion_panel(
      title = "UI options",
      icon = fontawesome::fa("sliders"),

      selectInput(
        inputId = ns("language"),
        # label = translator$t("Language"), # TODO: update translator
        label = "Language",
        choices = c("en", "es", "de"),
        width = "200px",
        selected = getOption("mergenstudio.language")
      )
    )
  )

  tagList(
    shinyjs::useShinyjs(),
    br(),
    br(),
    preferences
  )
}

#' @importFrom glue glue
#' @importFrom shinyjs show hide
#' @importFrom shinyFiles shinyDirChoose parseDirPath
#' @importFrom fs path_home
#' @noRd
mod_settings_server <- function(id, dir = NULL) {
  moduleServer(id, function(input, output, session) {

    ns <- session$ns
    rv <- reactiveValues()
    rv$selected_history <- 0L # originally 0L
    rv$modify_session_settings <- 0L
    rv$create_new_chat <- 0L
    # api_services <- c("openai-chat", "openai-completion", "replicate")
    api_services <- c("openai", "replicate", "generic")

    # choose directory
    rv$directory <- ifelse(is.null(dir), getwd(), dir)
    volumes <- c(ifelse(is.null(dir), getwd(), dir), fs::path_home())
    names(volumes) <- lapply(volumes, function(x){
      names_volumes <- strsplit(x, split = "\\/")[[1]]
      return(names_volumes[length(names_volumes)])
    })
    if(volumes[[1]]==volumes[[2]]) volumes <- volumes[1]
    shinyFiles::shinyDirChoose(input = input, id = "directory", session = session, roots = volumes)
    # observe({
    #   print(input$directorytext)
    #   if(input$directorytext == ""){
    #     print("merhaba")
    #     if(!is.null(dir)){
    #       updateTextInput(session, "directorytext", value = parseDirPath(roots=volumes, selection=rv$directory))
    #     }
    #   }
    # })
    observeEvent(input$directory, {
      updateTextInput(session, "directorytext", value = parseDirPath(roots=volumes, selection=input$directory))
      path <- shinyFiles::parseDirPath(roots = volumes, selection = input$directory)
      rv$directory <- as.character(path)
    })

    # rv$directory <- 0L
    # observeEvent(
    #   ignoreNULL = TRUE,
    #   eventExpr = {
    #     input$directory
    #   },
    #   handlerExpr = {
    #     if (input$directory > 0) {
    #       path = choose.dir(default = readDirectoryInput(session, ns('directory')),
    #                         caption="Choose a directory...")
    #       if(!is.character(path)){
    #         path <- getwd()
    #       }
    #       updateDirectoryInput(session, 'directory', value = path)
    #     } else {
    #       path <- getwd()
    #       updateDirectoryInput(session, 'directory', value = path)
    #     }
    #     rv$directory <- path
    #   }
    # )
    # output$directory = renderText({
    #   readDirectoryInput(session, ns('directory'))
    # })

    # hide api_url
    observe({
      # if api_url != generic, hide the api_url
      if(input$service != "generic"){
        updateTextInput(session, "api_url", value = "")
        shinyjs::hideElement("api_url")
      } else {
        shinyjs::showElement("api_url")
      }
    }) %>%
      bindEvent(input$service)

    # main observe
    observe({

      msg <- glue::glue("Fetching models for {input$service} service...")
      showNotification(ui = msg, type = "message", duration = 3, session = session)

      models <- get_available_models(input$service, token = input$api_key)

      if (length(models) > 0) {
        showNotification(ui = "Got models!", duration = 3, type = "message", session = session)

        updateSelectizeInput(
          session = session,
          inputId = "model",
          choices = models,
          selected = models[1]
        )

      } else {
        showNotification(ui = "No models available", duration = 3, type = "error", session = session)

        updateSelectizeInput(
          session = session,
          inputId = "model",
          choices = character(),
          selected = NULL
        )
      }
    }) %>%
      bindEvent(input$service, input$api_key)

    # # self correct cannot be used with completion models
    # observe({
    #   if(input$service == "openai-completion" && input$selfcorrect == TRUE){
    #     showNotification(ui = "selfcorrect cannot be used with type completion. Can only be used with type chat", duration = 3, type = "error", session = session)
    #     updateRadioButtons(
    #       session = session,
    #       inputId = "selfcorrect",
    #       choiceNames = c("Yes", "No"),
    #       choiceValues = c(TRUE, FALSE),
    #       selected = FALSE,
    #     )
    #   }
    # }) %>%
    #   bindEvent(input$service, input$selfcorrect)


    observe({
      rv$model <- input$model %||% getOption("mergenstudio.model")
      rv$service <- input$service %||% getOption("mergenstudio.service")
      rv$api_key <- input$api_key
      rv$api_url <- input$api_url
      rv$custom_context <- input$custom_context %||% getOption("mergenstudio.custom_context")
      rv$selfcorrect <- as.logical(input$selfcorrect %||% getOption("mergenstudio.selfcorrect"))
      rv$fileheader <- as.logical(input$fileheader %||% getOption("mergenstudio.fileheader"))
      rv$autoexecution <- as.logical(input$autoexecution %||% getOption("mergenstudio.autoexecution"))
      rv$nr_tokens <- input$nr_tokens
      # rv$settings <- input$directory
      # rv$settings <- as.character(parseDirPath(volumes, input$directory)) %||% getwd()
    })

    ## Module output ----
    rv
  })
}

get_available_context <- function(){
  c("actAs", "rbionfoExp", "CoT", "simple", "No Context")
}
